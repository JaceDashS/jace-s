name: Deploy to ECS

on:
  push:
    branches:
      - main  # ë˜ëŠ” master, production ë“± ì›í•˜ëŠ” ë¸Œëœì¹˜
  workflow_dispatch:  # ìˆ˜ë™ ì‹¤í–‰ë„ ê°€ëŠ¥í•˜ë„ë¡

permissions:
  contents: read
  issues: write

env:
  AWS_REGION: ap-northeast-2  # ì„œìš¸ ë¦¬ì „ (í•„ìš”ì‹œ ë³€ê²½)
  ECR_PUBLIC_REGISTRY: public.ecr.aws
  ECR_PUBLIC_ALIAS: ${{ secrets.ECR_PUBLIC_ALIAS }}  # ì˜ˆ: s7c1l0s2
  ECR_REPOSITORY: jace-s
  ECS_CLUSTER: your-cluster-name  # ì‹¤ì œ í´ëŸ¬ìŠ¤í„° ì´ë¦„ìœ¼ë¡œ ë³€ê²½
  ECS_SERVICE: your-service-name  # ì‹¤ì œ ì„œë¹„ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë³€ê²½
  ECS_TASK_DEFINITION: your-task-definition-name  # ì‹¤ì œ Task Definition ì´ë¦„ìœ¼ë¡œ ë³€ê²½
  CONTAINER_NAME: jace-s  # Task Definitionì˜ ì»¨í…Œì´ë„ˆ ì´ë¦„

jobs:
  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30  # ì „ì²´ ì‘ì—… íƒ€ì„ì•„ì›ƒ
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ì „ì²´ íˆìŠ¤í† ë¦¬ (ë””ë²„ê¹…ìš©)

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate AWS credentials
        id: validate-aws
        run: |
          echo "ğŸ” Validating AWS credentials..."
          if ! aws sts get-caller-identity; then
            echo "âŒ AWS credentials validation failed"
            exit 1
          fi
          echo "âœ… AWS credentials valid"
          echo "Account: $(aws sts get-caller-identity --query Account --output text)"
          echo "User: $(aws sts get-caller-identity --query Arn --output text)"

      - name: Login to Amazon ECR Public
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public
        continue-on-error: false

      - name: Set ECR Public registry
        id: ecr-registry
        run: |
          ECR_REGISTRY="${{ env.ECR_PUBLIC_REGISTRY }}/${{ env.ECR_PUBLIC_ALIAS }}"
          echo "registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT
          echo "âœ… ECR Public registry: $ECR_REGISTRY"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        id: install-deps
        run: |
          echo "ğŸ“¦ Installing dependencies..."
          npm ci || {
            echo "âŒ npm ci failed"
            echo "Trying npm install as fallback..."
            npm install
          }
          echo "âœ… Dependencies installed"

      - name: Run lint check
        id: lint-check
        continue-on-error: false
        run: |
          echo "ğŸ” Running ESLint..."
          npm run lint:check || {
            echo "âŒ Lint check failed"
            exit 1
          }
          echo "âœ… Lint check passed"

      - name: Run type check
        id: type-check
        continue-on-error: false
        run: |
          echo "ğŸ” Running TypeScript type check..."
          npm run type-check || {
            echo "âŒ Type check failed"
            exit 1
          }
          echo "âœ… Type check passed"

      - name: Get package version
        id: package-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Package version: $VERSION"

      - name: Install jq
        run: |
          echo "ğŸ“¦ Installing jq..."
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          else
            echo "âœ… jq is already installed"
          fi
          jq --version

      - name: Build Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.ecr-registry.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ³ Building Docker image..."
          echo "Registry: $ECR_REGISTRY"
          echo "Repository: ${{ env.ECR_REPOSITORY }}"
          echo "Tag: $IMAGE_TAG"
          echo "Version: ${{ steps.package-version.outputs.version }}"
          
          docker build \
            --build-arg NODE_ENV=production \
            --build-arg APP_VERSION=${{ steps.package-version.outputs.version }} \
            --build-arg NEXT_PUBLIC_BASE_URL=${{ secrets.NEXT_PUBLIC_BASE_URL }} \
            -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest \
            . || {
              echo "âŒ Docker build failed"
              echo "Build logs saved to build.log"
              exit 1
            }
          
          echo "âœ… Docker image built successfully"
          docker images | grep ${{ env.ECR_REPOSITORY }}

      - name: Push image to ECR Public
        id: push-image
        env:
          ECR_REGISTRY: ${{ steps.ecr-registry.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ“¤ Pushing image to ECR Public..."
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG || {
            echo "âŒ Failed to push image with tag $IMAGE_TAG"
            exit 1
          }
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest || {
            echo "âš ï¸ Failed to push latest tag (non-critical)"
          }
          echo "âœ… Image pushed successfully"
          echo "Image URI: $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

      - name: Update task definition with new image
        id: task-def
        env:
          ECR_REGISTRY: ${{ steps.ecr-registry.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ğŸ”„ Updating task definition with new image (sha tag)..."
          
          # í˜„ì¬ Task Definition ë‹¤ìš´ë¡œë“œ
          echo "ğŸ“¥ Downloading current task definition..."
          aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition > task-definition.json || {
              echo "âŒ Failed to download task definition"
              echo "Task definition name: ${{ env.ECS_TASK_DEFINITION }}"
              exit 1
            }
          
          # Task definition ê²€ì¦
          if [ ! -s task-definition.json ] || [ "$(cat task-definition.json)" = "null" ]; then
            echo "âŒ Task definition is empty or invalid"
            exit 1
          fi
          
          echo "âœ… Task definition downloaded"
          
          # ì»¨í…Œì´ë„ˆ ì´ë¦„ìœ¼ë¡œ ì»¨í…Œì´ë„ˆ ì°¾ê¸°
          CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
          echo "ğŸ” Looking for container: $CONTAINER_NAME"
          
          # ì»¨í…Œì´ë„ˆ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
          CONTAINER_EXISTS=$(jq --arg name "$CONTAINER_NAME" \
            '[.containerDefinitions[] | select(.name == $name)] | length' \
            task-definition.json)
          
          if [ "$CONTAINER_EXISTS" -eq 0 ]; then
            echo "âŒ Container '$CONTAINER_NAME' not found in task definition"
            echo "Available containers:"
            jq -r '.containerDefinitions[] | .name' task-definition.json
            exit 1
          fi
          
          echo "âœ… Container '$CONTAINER_NAME' found"
          echo "Current task definition preview for container '$CONTAINER_NAME':"
          jq --arg name "$CONTAINER_NAME" \
            '.containerDefinitions[] | select(.name == $name) | {name, image, cpu, memory}' \
            task-definition.json
          
          # ì´ë¯¸ì§€ URIë¥¼ sha íƒœê·¸ë¡œ êµì²´
          echo "ğŸ”„ Updating image URI to sha tag..."
          NEW_IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
          echo "New image URI: $NEW_IMAGE_URI"
          
          # ì»¨í…Œì´ë„ˆ ì´ë¦„ìœ¼ë¡œ ì°¾ì•„ì„œ ì´ë¯¸ì§€ URI ì—…ë°ì´íŠ¸
          jq --arg container_name "$CONTAINER_NAME" \
             --arg new_image "$NEW_IMAGE_URI" \
             '(.containerDefinitions[] | select(.name == $container_name) | .image) = $new_image' \
             task-definition.json > task-definition-new.json || {
              echo "âŒ Failed to update image in task definition"
              exit 1
            }
          
          # ì—…ë°ì´íŠ¸ëœ ì»¨í…Œì´ë„ˆ í™•ì¸
          UPDATED_CONTAINER_EXISTS=$(jq --arg name "$CONTAINER_NAME" \
            '[.containerDefinitions[] | select(.name == $name)] | length' \
            task-definition-new.json)
          
          if [ "$UPDATED_CONTAINER_EXISTS" -eq 0 ]; then
            echo "âŒ Container '$CONTAINER_NAME' not found after update (unexpected error)"
            exit 1
          fi
          
          # í•„ìˆ˜ í•„ë“œ ì œê±°
          echo "ğŸ§¹ Cleaning task definition (removing read-only fields)..."
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            task-definition-new.json > task-definition-updated.json || {
              echo "âŒ Failed to clean task definition"
              exit 1
            }
          
          # Task definition ê²€ì¦
          echo "Validating task definition..."
          if ! jq empty task-definition-updated.json 2>/dev/null; then
            echo "âŒ Invalid JSON in task definition"
            exit 1
          fi
          
          # ì—…ë°ì´íŠ¸ëœ ì´ë¯¸ì§€ URI í™•ì¸
          echo "Updated task definition preview for container '$CONTAINER_NAME':"
          jq --arg name "$CONTAINER_NAME" \
            '.containerDefinitions[] | select(.name == $name) | {name, image, cpu, memory}' \
            task-definition-updated.json
          
          # ìƒˆ revision ë“±ë¡
          echo "ğŸ“ Registering new task definition revision with updated image..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition-updated.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text) || {
              echo "âŒ Failed to register task definition"
              echo "Task definition content:"
              cat task-definition-updated.json
              exit 1
            }
          
          if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" = "None" ]; then
            echo "âŒ Task definition ARN is empty"
            exit 1
          fi
          
          REVISION=$(echo $TASK_DEF_ARN | awk -F/ '{print $NF}' | awk -F: '{print $NF}')
          
          echo "task-definition-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "revision=$REVISION" >> $GITHUB_OUTPUT
          
          echo "âœ… New task definition revision registered"
          echo "Task Definition ARN: $TASK_DEF_ARN"
          echo "Revision: $REVISION"
          echo "Image URI: $NEW_IMAGE_URI"

      - name: Verify ECS service exists
        run: |
          echo "ğŸ” Verifying ECS service..."
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0]' \
            --output json) || {
              echo "âŒ Failed to describe ECS service"
              exit 1
            }
          
          if [ "$(echo $SERVICE_INFO | jq -r '.status')" = "null" ]; then
            echo "âŒ ECS service not found"
            echo "Cluster: ${{ env.ECS_CLUSTER }}"
            echo "Service: ${{ env.ECS_SERVICE }}"
            exit 1
          fi
          
          echo "âœ… ECS service found"
          echo "Service status: $(echo $SERVICE_INFO | jq -r '.status')"
          echo "Desired count: $(echo $SERVICE_INFO | jq -r '.desiredCount')"
          echo "Running count: $(echo $SERVICE_INFO | jq -r '.runningCount')"

      - name: Force new deployment
        id: force-deploy
        run: |
          echo "ğŸš€ Starting force deployment..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.task-def.outputs.task-definition-arn }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }} || {
              echo "âŒ Failed to update ECS service"
              exit 1
            }
          
          echo "âœ… Deployment initiated"
          echo "Waiting for service to start updating..."

      - name: Wait for service to stabilize
        id: wait-stable
        timeout-minutes: 15
        run: |
          echo "â³ Waiting for ECS service to stabilize (max 15 minutes)..."
          
          # ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} || {
              echo "âŒ Service did not stabilize within timeout"
              echo "Checking service status..."
              
              # ì‹¤íŒ¨ ì›ì¸ ì¡°ì‚¬
              SERVICE_INFO=$(aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --query 'services[0]' \
                --output json)
              
              echo "Service status: $(echo $SERVICE_INFO | jq -r '.status')"
              echo "Desired count: $(echo $SERVICE_INFO | jq -r '.desiredCount')"
              echo "Running count: $(echo $SERVICE_INFO | jq -r '.runningCount')"
              echo "Pending count: $(echo $SERVICE_INFO | jq -r '.pendingCount')"
              
              # ì‹¤íŒ¨í•œ íƒœìŠ¤í¬ í™•ì¸
              FAILED_TASKS=$(aws ecs list-tasks \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service-name ${{ env.ECS_SERVICE }} \
                --desired-status STOPPED \
                --query 'taskArns[0:5]' \
                --output json)
              
              if [ "$FAILED_TASKS" != "[]" ] && [ "$FAILED_TASKS" != "null" ]; then
                echo "Recent stopped tasks:"
                echo $FAILED_TASKS | jq -r '.[]' | while read task_arn; do
                  echo "Task: $task_arn"
                  aws ecs describe-tasks \
                    --cluster ${{ env.ECS_CLUSTER }} \
                    --tasks $task_arn \
                    --query 'tasks[0].{stopCode:stopCode,stoppedReason:stoppedReason,containers:containers[*].{name:name,reason:reason,exitCode:exitCode}}' \
                    --output json
                done
              fi
              
              exit 1
            }
          
          echo "âœ… Service stabilized successfully"

      - name: Verify deployment
        run: |
          echo "ğŸ” Verifying deployment..."
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0]' \
            --output json)
          
          RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
          
          if [ "$RUNNING_COUNT" -lt "$DESIRED_COUNT" ]; then
            echo "âš ï¸ Warning: Running count ($RUNNING_COUNT) is less than desired count ($DESIRED_COUNT)"
          fi
          
          echo "âœ… Deployment verified"
          echo "Running tasks: $RUNNING_COUNT / $DESIRED_COUNT"
          echo "Task definition: $(echo $SERVICE_INFO | jq -r '.taskDefinition')"

      - name: Health check after deployment
        id: health-check
        env:
          HEALTH_URL: https://jace-s.com/health
        run: |
          echo "ğŸ¥ Performing health check..."
          sleep 30  # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸°
          
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s $HEALTH_URL > /dev/null; then
              echo "âœ… Health check passed"
              
              # ë²„ì „ ì •ë³´ í™•ì¸
              HEALTH_RESPONSE=$(curl -s $HEALTH_URL)
              echo "Health check response:"
              echo "$HEALTH_RESPONSE" | jq .
              
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "â³ Health check failed, retrying... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 10
          done
          
          echo "âŒ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deployment summary
        if: always()
        run: |
          echo "## ğŸ“Š Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… **Status**: Success" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Status**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: \`${{ steps.package-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image**: \`${{ steps.ecr-registry.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Task Definition**: \`${{ steps.task-def.outputs.task-definition-arn }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Service**: \`${{ env.ECS_SERVICE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: \`${{ env.ECS_CLUSTER }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

      # ì‹¤íŒ¨ ì‹œ ì•Œë¦¼ (ì„ íƒì‚¬í•­)
      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ Deployment failed: ${{ github.ref_name }}`,
              body: `Deployment failed for commit ${{ github.sha }}\n\nSee workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`,
              labels: ['deployment', 'failure']
            })

